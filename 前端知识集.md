# 前端知识集

下面几个都会转化为0：

![1534835242643](D:\MyData\zousy1\AppData\Local\Temp\1534835242643.png)

![1534835252684](D:\MyData\zousy1\AppData\Local\Temp\1534835252684.png)



1、HTML5的优点与缺点？ 

###Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？

声明位于文档中的最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）

回答1： （1）、 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 

​            （2）、严格模式的排版和JS 运作模式是以该浏览器支持的最高标准运行。 

​            （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。               （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 

###你做的网页在哪些浏览器测试过,这些浏览器的内核分别是什么?

a、 IE: trident 内核

b、 Firefox ： gecko 内核

c、 Safari:webkit 内核

d、 Opera: 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核

e、 Chrome:Blink( 基于 webkit ， Google 与 Opera Software 共同开发 )

###HTML5有哪些新特性、移除了哪些元素？

**HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合** 

Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。

结构性元素主要负责web上下文结构的定义

section：在 web 页面应用中，该元素也可以用于区域的章节描述。

header：页面主体上的头部， header 元素往往在一对 body 元素中。

footer：页面的底部（页脚），通常会标出网站的相关信息。

nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。

article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。

级块性元素主要完成web页面区域的划分，确保内容的有效分割。

aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。

figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。

code：表示一段代码块。

dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。

行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。

meter：表示特定范围内的数值，可用于工资、数量、百分比等。

time：表示时间值。

progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。

video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。

audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。

交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。

details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。

datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。

menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。

command：用来处理命令按钮。

####HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?

```
(1)行内元素

a - 锚点

* abbr - 缩写

* acronym - 首字

* b - 粗体 ( 不推荐 )

* bdo - bidi override

* big - 大字体

* br - 换行

* cite - 引用

* code - 计算机代码 ( 在引用源码的时候需要 )

* dfn - 定义字段

* em - 强调

* font - 字体设定 ( 不推荐 )

* i - 斜体

* img - 图片

* input - 输入框

* kbd - 定义键盘文本

* label - 表格标签

* q - 短引用

* s - 中划线 ( 不推荐 )

* samp - 定义范例计算机代码

* select - 项目选择

* small - 小字体文本

* span - 常用内联容器，定义文本内区块

* strike - 中划线

* strong - 粗体强调

* sub - 下标

* sup - 上标

* textarea - 多行文本输入框

* tt - 电传文本

* u - 下划线

* var - 定义变量

(2)块元素 (block element)

* address - 地址

* blockquote - 块引用

* center - 居中对齐块

* dir - 目录列表

* div - 常用块级容易，也是 css layout 的主要标签

* dl - 定义列表

* fieldset - form控制组

* form - 交互表单

* h1 - 大标题

* h2 - 副标题

* h3 - 3级标题

* h4 - 4级标题

* h5 - 5级标题

* h6 - 6级标题

* hr - 水平分隔线

* isindex - input prompt

* menu - 菜单列表

* noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容

* noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容）

* ol - 排序表单

* p - 段落

* pre - 格式化文本

* table - 表格

* ul - 非排序列表

可变元素

可变元素为根据上下文语境决定该元素为块元素或者内联元素。

* applet - java applet

* button - 按钮!!!!!!!

* del - 删除文本

* iframe - inline frame

* ins - 插入的文本

* map - 图片区块 (map)

* object - object对象

* script - 客户端脚本

(3)空元素 ( 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 )

<br/> //换行

<hr> //分隔线

<input> //文本框等

<img> //图片

<link> <meta>
```

### 请你描述一下 cookies，sessionStorage 和 localStorage 的区别?

```
sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。

sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的

cookies会发送到服务器端。其余两个不会。

Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。

区别：

- Cookie

+ 每个域名存储量比较小（各浏览器不同，大致 4K ）

+ 所有域名的存储量有限制（各浏览器不同，大致 4K ）

+ 有个数限制（各浏览器不同）

+ 会随请求发送到服务器

- LocalStorage

+ 永久存储

+ 单个域名存储量比较大（推荐 5MB ，各浏览器不同）

+ 总体数量无限制

- SessionStorage

+ 只在 Session 内有效

+ 存储量更大（推荐没有限制，但是实际上各浏览器也不同）
```



#### typeof 

typeof只返回 string  number object 还有 undefined function ，number 就包含了float , 

#### js类型转换

Infinity 属性用于存放表示正无穷大的数值。 

####隐式类型转换（自动类型转换）

当js期望得到某种类型的值，而实际在那里的值是其他的类型，就会发生隐式类型转换。系统内部会自动调用我们前面说ToBoolean ( argument )、ToNumber ( argument )、ToString ( argument )，尝试转换成期望的数据类型。 例子1：



```json
if ( !undefined

  && !null

  && !0

  && !NaN

  && !''

) {

  console.log('true');

} // true

```

```js

```

```
> function returnObject() { return {} }



> 3 * { valueOf: function () { return {} }, toString: function () { return {} } }



// TypeError: Cannot convert object to primitive value
12+3



// 15



12+'3'
```

```
> function returnObject() { return {} }



> 3 * { valueOf: function () { return {} }, toString: function () { return {} } }
```

例子3：调用ToNumber ( argument )的过程中，调用了ToPrimitive ( input , Number )，因为在ToPrimitive中valueOf和toString都没有返回原始类型，所以抛出异常。 符号'+'是一个比较棘手的一个符号，因为它既可以表示“算数加法”，也可以表示“字符串拼接”。 简单理解版本：只要'+'两端的任意一个操作数是字符串，那么这个'+'就表示字符串拼接，否则表示算数加法。 

https://blog.csdn.net/just_do_it2009/article/details/71079784

https://blog.csdn.net/chenjh213/article/details/51114048

**hasOwnProperty：** 是用来判断一个对象是否有你给出名称的属性或对象。不过需要注意的是，此方法无法检查该对象的原型链中是否具有该属性，该属性必须是对象本身的一个成员。

**isPrototypeOf :** 是用来判断要检查其原型链的对象是否存在于指定对象实例中，是则返回true，否则返回false。



###说一说常见的请求头和相应头都有什么呢？

####1)请求(客户端->服务端[request]) 

​    GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) 
    Accept: */*(客户端能接收的资源类型) 
    Accept-Language: en-us(客户端接收的语言类型) 
    Connection: Keep-Alive(维护客户端和服务端的连接关系) 
    Host: localhost:8080(连接的目标主机和端口号) 
    Referer: http://localhost/links.asp(告诉服务器我来自于哪里) 
    User-Agent: Mozilla/4.0(客户端版本号的名字) 
    Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) 
    If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  
    Cookie(客户端暂存服务端的信息) 
    Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)

####2)响应(服务端->客户端[response])

​    HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
    Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
    Server:apache tomcat(服务端的Web服务端名)
    Content-Encoding: gzip(服务端能够发送压缩编码类型) 
    Content-Length: 80(服务端发送的压缩数据的长度) 
    Content-Language: zh-cn(服务端发送的语言类型) 
    Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
    Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
    Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)
    Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
    Transfer-Encoding: chunked(分块传递数据到客户端）  
    Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
    Expires: -1//3种(服务端禁止客户端缓存页面数据)
    Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  
    Pragma: no-cache(服务端禁止客户端缓存页面数据)   
    Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  
    Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)
在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。

####DNS

A：DNS就是将域名翻译成IP地址。

B：主要用UDP，但是当请求字节过长超过512字节时用TCP协议，将其分割成多个片段传输。

C：DNS协议默认端口号是53。

D：操作系统的DNS缓存：windows DNS缓存的默认值是 MaxCacheTTL，它的默认值是86400s，也就是一天。macOS 严格遵循DNS协议中的TTL。

游览器的DNS缓存：chrome对每个域名会默认缓存60s；IE将DNS缓存30min；Firefox默认缓存时间只有1分钟；Safari约为10S。

####Ajax技术核心就是XMLHttpRequest对象。

Ajax技术的工作原理：可以分成3步

1.创建Ajax对象：var xhr = new XMLHttpRequest();

2.xhr 发送请求：xhr.open('get','test.html','true');

​                          xhr.send();

3.xhr获取响应：

```


                          xhr.onreadystatechange = function(){

                                   if(xhr.readystate == 4){//请求的状态码

                                                       /*

                                                                   0:请求还没有建立（open执行前）

                                                                   1：请求建立了还没发送（执行了open）

                                                                    2：请求正式发送（执行了send）

                                                                   3：请求已受理，有部分数据可以用，但还没有处理完成

                                                                 4：请求完全处理完成

                                                           */

                                         alert(xhr.responseText);//返回的数据

                                     }

                             }

```



可以看到，send()前是open()

### 浏览器是如何实现跨域的

https://blog.csdn.net/angle_jian/article/details/79491142

https://blog.csdn.net/ligang2585116/article/details/73072868

### ajax实现原理

