# vue



## vue大厂最佳实践

![1585812889816](imge/1585812889816.png)

1，全局组件注册

![1585813908377](imge/1585813908377.png)

插件安装全局组件

require.context是webpack的方法

![1585814160599](imge/1585814160599.png)

Vue.use()  require.context

---

业务分层

![1585816968833](imge/1585816968833.png)



require.context用来拿多个文件，

**而不用新增一个文件，就import一个新的，然后在...引入**，不用维护，组件写好就行

default就是拿模块默认暴露出的东西

懒加载的原理：路由一点击的时候执行import

![1585817232935](imge/1585817232935.png)

---

render函数

![1585817392705](imge/1585817392705.png)

![1585817676025](imge/1585817676025.png)

render中的h就是createElement

render中创建的dom和template中创建的dom有什么区别

vue模板做出的是虚拟dom

render函数生成的是真实dom。（render省去了转义成vnode的过程）

在js中写复杂逻辑

![1585819324098](imge/1585819324098.png)

template值判断多，vnode



全局权限控制

全局自定义指令来做权限

![1585819945032](imge/1585819945032.png)

![1585819989483](imge/1585819989483.png)

----

简易的存储一个变量

用一些替代的（其实不会去用）

----

#　ｖｕｅ技巧

- vuex的替代方案
- 打包优化
- 插件解决项目中问题

## vuex替代

1，bus

2，store代替vuex，如下图

![1585877601107](imge/1585877601107.png)

使用vue.observable来监听变量

![1585877690356](imge/1585877690356.png)

没有讲bus是怎么用的（全局组件）

## 如何对vue进行优化

- 减少resolve，限制include
- 要处理的内容数量
- 要进行的操作
- 你的版本

### dll优化

dll原理

每次打包都会处理所有的内容，其实并不会更改第三方包-vue，jquery，axios

 先打包第三包-告诉真正的包那些第三方包已经被处理了

实现：分成两步1，提前运行dll打包命令生成包预打包文件。2，将打包好的js文件引入正式打包的webpack中。提升打包速度。可以实践下。

### vue.use开发插件

中使用vue.minx来混入生命钩子，修改所有的组件的生命周期，vue.use方法里面优先执行传入的对象的install方法，如果传入的是一个函数，并且这个函数上无install方法，则执行这个函数。

----

###　Vuex过大，导致打包结果过大

**按组件异步拆分加载vuex**

55分钟

![1586994243299](imge/1586994243299.png)

每个组件按组件名的store分不同文件名分开来，写成不同文件，

如果写个插件，为每个vue组件混入一个created生命钩子，在这个钩子里面，根据在组件中定义的属性，判断是否需要引入对应的vuex，需要就使用import异步引入。import中参数只接受字符串？

![1586994561947](imge/1586994561947.png)

拿到之后，注册到store中。

---

## ssr

![image-20200423220819858](imge/image-20200423220819858.png)

![image-20200423221640965](imge/image-20200423221640965.png)

![image-20200425205858290](imge/image-20200425205858290.png)

拿到url，使用插件vue-server-render来转化对应的ssr的html。

![image-20200425210114952](imge/image-20200425210114952.png)

代替浏览器将一个vue实例变成html

如何集成到vue项目中

![image-20200425210654778](imge/image-20200425210654778.png)![image-20200425212751996](imge/image-20200425212751996.png)

![image-20200425212836463](imge/image-20200425212836463.png)

![image-20200425213427188](imge/image-20200425213427188.png)

![image-20200425213615311](imge/image-20200425213615311.png)

![image-20200425214335353](imge/image-20200425214335353.png)

![image-20200425214501414](imge/image-20200425214501414.png)

跑在node端中的，也就是在node中的

看不懂，说明对node不了解

![image-20200425215006398](imge/image-20200425215006398.png)

inject：是否默认插入打包结果就默认帮html入口文件插入打包后的js文件

因为ssr，只生成html，到时候会插入客户端js文件

（ssr：加快首屏渲染，白屏，seo）

![image-20200425215326090](imge/image-20200425215326090.png)

对应着之前html中配置的变量![image-20200425215445876](imge/image-20200425215445876.png)

![image-20200425220215318](imge/image-20200425220215318.png)![image-20200425220222510](imge/image-20200425220222510.png)

使用next就行

![image-20200425221539141](imge/image-20200425221539141.png)

先学基础，把其他放一放

