#  第一章

![image-20200802101336663](imge/image-20200802101336663.png)

![image-20200802101409787](imge/image-20200802101409787.png)

单向数据流有什么好处？？

![image-20200802101624922](imge/image-20200802101624922.png)

![image-20200802101631367](imge/image-20200802101631367.png)

相当于react中一直用store方式来操作数据

而vue双向数据流，直接修改store也能触发更新

![image-20200802103639622](imge/image-20200802103639622.png)

![image-20200802103817034](imge/image-20200802103817034.png)

![image-20200802103933531](imge/image-20200802103933531.png)

react整体更新也是更新一个组件

![image-20200802104043630](imge/image-20200802104043630.png)

react的生命周期

![image-20200802145111646](imge/image-20200802145111646.png)

![image-20200802145138316](imge/image-20200802145138316.png)

![image-20200802145200075](imge/image-20200802145200075.png)

![image-20200802145237516](imge/image-20200802145237516.png)

![image-20200802145250184](imge/image-20200802145250184.png)

![image-20200802145309451](imge/image-20200802145309451.png)

第一章 ：React 基础 (10讲)
01 | 课程介绍免费
02 | React出现的历史背景及特性介绍免费
03 | 以组件方式考虑UI的构建免费
04 | JSX的本质 : 不是模板引擎，而是语法糖免费
05 | React组件的生命周期及其使用场景
06 | 理解Virtual DOM及key属性的作用

![image-20200802145833453](imge/image-20200802145833453.png)

广度分层，一层层分析（局部更新算法复杂度为0（n））

1，每个节点都需要一个唯一标识，这样才能知道，顺序发生变化了

![image-20200802150535124](imge/image-20200802150535124.png)

相同类型的兄弟节点，就可以被唯一标识

07 | 组件设计模式 : 高阶组件和函数作为子组件

![image-20200802150709389](imge/image-20200802150709389.png)

调用其他组件

08 | 理解新的Context API及其使用场景

![image-20200802152236204](imge/image-20200802152236204.png)

![image-20200802152621391](imge/image-20200802152621391.png)

![image-20200802152634506](imge/image-20200802152634506.png)

![image-20200802152651768](imge/image-20200802152651768.png)



![image-20200802152713262](imge/image-20200802152713262.png)

![image-20200802152735028](imge/image-20200802152735028.png)

09 | 使用脚手架工具创建React项目
10 | 打包和部署



![image-20200802152856433](imge/image-20200802152856433.png)



第二章 ：React 生态圈 (12讲)

11 | Redux（1） : 前端为何需要状态管理库

![image-20200802154226623](imge/image-20200802154226623.png)

全局只有一个redux



![image-20200802154454066](imge/image-20200802154454066.png)和vue中相同

![image-20200802154512712](imge/image-20200802154512712.png)

了解下，记录下这个东西是什么，讲了什么

每章一个总结：说明这是什么，怎么用

12 | Redux（2） : 深入理解Store、Action、Reducer



![image-20200802161442699](imge/image-20200802161442699.png)

13 | Redux（3） : 在React中使用Redux

将组件和store 链接起来，用的是![image-20200802162545794](imge/image-20200802162545794.png)

vue中可以直接使用this.$store,还有全局的mapState方法

![image-20200802162658943](imge/image-20200802162658943.png)

用的高阶组件封装了，要访问store的组件



![image-20200802162933454](imge/image-20200802162933454.png)



14 | Redux（4） : 理解异步Action、Redux中间件



![image-20200802163010694](imge/image-20200802163010694.png)

中间件会去分析actions中，如果是请求接口的，就会拦截，请求完api之后再进行dispatcher

![image-20200802163214857](imge/image-20200802163214857.png)

异步action是有多个同步actions组成的，根据promise的状态进行操作

 根据不同状态（promise中的pedding reject...），将state设置成不同状态，然后reduceer根据不同状态来设置对应的数据state



![image-20200802163728093](imge/image-20200802163728093.png)

比vue中多了一个type类型，根据类型来判断异步状态



15 | Redux（5） : 如何组织Action和Reducer

![image-20200802163830610](imge/image-20200802163830610.png)





![image-20200802163854139](imge/image-20200802163854139.png)

一个更好的组织方式



16 | Redux（6） : 理解不可变数据（Immutability）

![image-20200802163927830](imge/image-20200802163927830-1596357586359.png)

不可变数据是什么意思：不能直接修改，要复制值，产生新对象的方式来达到改变的目的

![image-20200802164119259](imge/image-20200802164119259.png)

使用不可变，当新的state和旧的state不是同一个对象，那么就不用比较就可以知道state发生了变化

![image-20200802164246422](imge/image-20200802164246422.png)





17 | React Router（1）：路由不只是页面切换，更是代码组织方式

![image-20200802164419967](imge/image-20200802164419967.png)

![image-20200802164451455](imge/image-20200802164451455.png)

内存路由实际上不会显示到url上，就内存起来

路由懒加载：很重要todo1

18 | React Router（2）：参数定义，嵌套路由的使用场景
19 | UI组件库对比和介绍：Ant.Design、Material UI、Semantic UI

![image-20200802165506822](imge/image-20200802165506822.png)

ant.design： 面向公司，面向大型的数据展示，

material  更好看

semantic 更老，class

![image-20200802165701796](imge/image-20200802165701796.png)



20 | 使用Next.js创建React同构应用

![image-20200802165733235](imge/image-20200802165733235.png)

ssr

![image-20200802165826530](imge/image-20200802165826530.png)

![image-20200802165852372](imge/image-20200802165852372.png)

![image-20200802165912683](imge/image-20200802165912683.png)

![image-20200802165926650](imge/image-20200802165926650.png)

21 | 使用Jest、Enzyme等工具进行单元测试

![image-20200802165954245](imge/image-20200802165954245.png)

![image-20200802170010746](imge/image-20200802170010746.png)

![image-20200802170227229](imge/image-20200802170227229.png)

对源代码埋点

![image-20200802170309204](imge/image-20200802170309204.png)



22 | 常用开发调试工具：ESLint、Prettier、React DevTool、Redux DevTool
第三章 ：构建可维护可扩展的前端应用 (6讲)

23 | 前端项目的理想架构：可维护、可扩展、可测试、易开发、易建构

![image-20200802200854910](imge/image-20200802200854910.png)

![image-20200802200909561](imge/image-20200802200909561.png)

![image-20200802200937927](imge/image-20200802200937927.png)

![image-20200802200949228](imge/image-20200802200949228.png)

![image-20200802201041546](imge/image-20200802201041546.png)



24 | 拆分复杂度（1）：按领域模型（feature）组织代码，降低耦合度



![image-20200802201106394](imge/image-20200802201106394.png)



25 | 拆分复杂度（2）：如何组织component、action和reducer



![image-20200802201153230](imge/image-20200802201153230.png)

![image-20200802201218129](imge/image-20200802201218129.png)

26 | 拆分复杂度（3）：如何组织React Router的路由配置
27 | 使用Rekit（1）：创建项目，代码生成和重构

![image-20200802201256064](imge/image-20200802201256064.png)

28 | 使用Rekit（2）：遵循最佳实践，保持代码一致性
第四章 ：常见场景的最佳实践 (13讲)

29 | 使用React Router管理登录和授权
30 | 实现表单（1）：初始数据，提交和跳转
31 | 实现表单（2）：错误处理，动态表单元素，内容动态加载
32 | 列表页（1）：搜索，数据缓存和分页
33 | 列表页（2）：缓存更新，加载状态，错误处理
34 | 页面数据需要来源多个请求的处理
35 | 内容页的加载与缓存
36 | 基于React Router实现分步操作
37 | 常见页面布局的实现
38 | 使用React Portals实现对话框，使用antd对话框
39 | 集成第三方JS库：以d3.js为例
40 | 基于路由实现菜单导航
41 | React中拖放的实现

![image-20200802202359808](imge/image-20200802202359808.png)



监听ommousedown按下鼠标事件

最外层加一个div，拖动的时候就把div放出，在div上监听mousemove

然后计算偏移值

![image-20200802202735253](imge/image-20200802202735253.png)

可以下载对应代码

第五章：React性能优化 (5讲)
42 | 性能永远是第一需求：时刻考虑性能问题

![image-20200802202920802](imge/image-20200802202920802.png)

![image-20200802203042213](imge/image-20200802203042213.png)

组件更细，更多是纯组件

43 | 网络性能优化：自动化按需加载

![image-20200802203217503](imge/image-20200802203217503.png)

webpack会把improt后面的单独打成一个包，等运行到了再去加载对应的文件

react-loadable高阶组件实现loading状态



44 | 使用Reselect避免重复计算

计算属性中的缓存计算结果

高阶组件实现

45 | 下一代React：异步渲染

![image-20200802204122505](imge/image-20200802204122505.png)

![image-20200802204459242](imge/image-20200802204459242.png)

![image-20200802204614500](imge/image-20200802204614500.png)

用户操作频繁的时候会不停渲染会卡顿，如果异步之后，会等用户输入分片执行

![image-20200802204729380](imge/image-20200802204729380.png)



使用Chrome DevTool进行性能调优&结课测试

![image-20200802204748326](imge/image-20200802204748326.png)

![image-20200802204808897](imge/image-20200802204808897.png)

