

## 模块化规范，CMD原理是什么？

amd和cmd源码实现原理

https://juejin.im/post/5c3592b26fb9a049aa6f4456#heading-9

看这篇文章

然后就把剩下的文章好好看下

然后就看webpack面试题

webpack中的模块化是如何实现的

### AMD实现原理

amd标准中require.js用的最佳实践

define函数的第一个参数是个数组，写的是所依赖的模块；第二个参数是回调函数，回调函数里的参数对应的是依赖数组里的模块返回值，如：

![img](https://user-gold-cdn.xitu.io/2019/1/9/16831cd8d9512709?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

otherModule就是依赖的模块other的返回值

```
es6 :

import A from 'a.js'

import B from 'b.js'

require.js:

define(['a.js', 'b.js'], function(A, B) {

})
```

无论是CMD还是AMD，都只是让开发者写代码时变爽了，而对于浏览器来说，可以认为没啥太大变化，该加载多少js文件，js文件的顺序，都和以前没啥区别！！！

webpack可以打包成一个js

- 文件加载/文件运行 顺序： 1.js , 2.js , 3.js
- 模块运行 顺序：3.js , 2.js , 1.js

打开1.js才知道依赖的文件

**require.js 简单源码原理**（递归收集依赖，加载依赖）

**利用递归去加载层层的嵌套依赖**，代码的难点就在于，怎样判断递归结束？即怎样判断所有的依赖都加载完了？

根据上面分析的文件顺序，递归加载文件，加载完了判断是否所有依赖都加载完成，完成后就去掉该文件id

### AMD和CMD的区别

对依赖模块的**执行时机**不同，注意：不是加载的时机，模块加载的时机是一样的！！！

**文件加载顺序：** 都是先加载1.js，再加载2.js，最后加载3.js

**模块运行顺序**：

**AMD：** 3.js，2.js，1.js，，，即如果模块以及该模块的依赖都加载完了，那么就执行。。。 比如 3.js 加载完后，发现自己也没有依赖啊，那么直接执行3.js的回调了，，，2.js加载完后探查到依赖的3.js也加载完了，那么2.js就执行自己的回调了。。。。 主模块一定在最后执行

**CMD：** 1.js，2.js，3.js，，，即先执行主模块1.js，碰到require('2.js')就执行2.js，2.js中碰到require('3.js')就执行3.js

会不会又不理解，怎么能控制执行哪个文件模块呢？啥时执行呢？

还记得不，之前说过，**执行模块**，是指的执行那个functionA回调函数，callback，，，那么这个callback函数其实在一开始执行define()中，就已经通过参数，赋到了modules上了啊，所以无论CMD还是AMD，**执行模块**，都是执行modules[id].callback()

----

也就是说，`require.js`和`sea.js`都是在执行模块前预加载了依赖的模块，并没有比`require.js`显得更“懒加载”，只是所依赖模块的代码执行时机不同。`require.js`加载时执行，而`sea.js`是使用时执行。

2、而AMD是**依赖前置**的，换句话说，**在解析和执行当前模块之前，模块作者必须指明当前模块所依赖的模块**

1、CMD推崇**依赖就近**，**可以把依赖写进你的代码中的任意一行**，例：

原理：

**所以sea.js，是写了一个正则的函数，去查询define中传入的fn的字符串，然后得到的依赖数组。。。 而require.js的依赖数组，是咱们自己写并且传入的：define(['2.js'])。。。**

----

有几种规范： 1，commonjs  2，amd cmd es6

**判断该模块是否存在缓存对象中，若是则返回缓存对象中对应模块，若否则定义模块对象并存储进缓存对象中**；

**执行 modules 对象中对应模块的函数（在函数中会将该模块输出的内容存储进 module.exports 中）**；

**返回该模块 module.exports**；

webpack会根据你用了那些规范语法来进行对应模块化



-----

讲讲 JS 的模块化3
太慢了，弄成一个固定的章节来学习，学习里面的原理
2-1-1、 CommonJS常见规范
一个文件就是一个模块，拥有单独的作用域
普通方式定义的 变量、函数、对象都属于该模块内
通过 require 来加载模块
通过 exports 和 module.exports 来暴露模块中的内容
node 的模块化和浏览器的模块化有什么区别？4
todo： 模块化
es6 为什么要实现 export/import ，而不是照着 Node 的模块化语法实现5



如何总结清楚 

commonjs是编译后放在磁盘里面，是模块导出的值拷贝

es6是编译的时候生成一个引用地址，然后运行的时候再去取值

浏览器端要异步，不能阻塞js主线程





