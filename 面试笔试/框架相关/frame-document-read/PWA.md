# PWA文档阅读

当用户打开我们站点时（从桌面 icon 或者从浏览器），通过 Service Worker 能够让用户在网络条件很差的情况下也能瞬间加载并且展现。

Service Worker 是用 JavaScript 编写的 JS 文件，能够代理请求，并且能够操作浏览器缓存，通过将缓存的内容直接返回，让请求能够瞬间完成。开发者可以预存储关键文件，可以淘汰过期的文件等等，给用户提供可靠的体验。



service worker 是一个js文件，通过代理请求，操作浏览器缓存。达到无网络的状态太可以快速打开网页

Manifest，则可以实现浏览器端安装应用，显示桌面图标，发送用户通知

## service worker

service worker的来源

由于js单线程在面对越来越复杂的计算和处理上，加了很多耗资源、耗时间的复杂运算过程，让网站的性能变差

所以就有了一个worker进程，处理一些耗时间的事情，作为了之后就通知主线程。

之后再给这个worker进程添加存储文件的能力，显现持久离线缓存能力

>Service Worker 有以下功能和特性：
>
>- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。
>- 一旦被 install，就永远存在，除非被手动 unregister
>- 用到的时候可以直接唤醒，不用的时候自动睡眠
>- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）
>- 离线内容开发者可控
>- 能向客户端推送消息
>- 不能直接操作 DOM
>- **必须在 HTTPS 环境下才能工作**
>- 异步实现，内部大都是通过 Promise 实

### 自定义请求响应头

目的就是将请求缓存起来

怎么缓存，第一service worker控制的资源请求时会触发fetch事件（这个是一种请求服务器的方式，之前是xhr，ajax是封装了xhr。内核是使用了promise）

触发了fetch事件之后就根据请求来缓存文件

我们可以在 `install` 的时候进行静态资源缓存，也可以通过 `fetch` 事件处理回调来代理页面请求从而实现动态资源缓存。

### 关于版本问题

应用中如果需要更新，可以采用各种方法保证合理更新

并且浏览器会保证24小时一次的更新

 Service Worker 会每天更新一次。

##  Service Worker 生命周期

Service Worker 的使用过程很简单，所处理的事情也相对单一，我们基本上需要做的就是利用这个 API 做好站点的缓存策略。在页面脚本中注册 Service Worker 文件所在的 URL。Worker 就可以开始激活了，**激活后的 Service Worker 可以监听当前域下的功能性事件，比如资源请求（`fetch`）、推送通知（`push`）、后台同步（`sync`）。**在这一系列的流程中，从 Service Worker 的注册到消失，经历了生命周期中不同的状态

### 如何进行service worker调试

