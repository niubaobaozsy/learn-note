# 深拷贝

## 简单的深拷贝

```js

function cloneDeep1(source) {
    var target = {};
    Object.keys(source).forEach(key=>{
            if (typeof source[key] === 'object') {
                target[key] = cloneDeep1(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }  
   		 }
    })
    return target;
}

```

一个简单的深拷贝就完成了，但是这个实现还存在很多问题。

- 1、没有对传入参数进行校验，传入 `null` 时应该返回 `null` 而不是 `{}`
- 2、对于对象的判断逻辑不严谨，因为 `typeof null === 'object'`
- 3、没有考虑数组的兼容

```js
function cloneDeep2(source) {

    if (!isObject(source)) return source; // 非对象返回自身
      
    var target = Array.isArray(source) ? [] : {};
    for(var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (isObject(source[key])) {
                target[key] = cloneDeep2(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
```

我们知道 `JSON` 无法深拷贝循环引用，遇到这种情况会抛出异常。

```
// 木易杨
// 此处 a 是文章开始的测试用例
a.circleRef = a;

JSON.parse(JSON.stringify(a));
// TypeError: Converting circular structure to JSON
```


```js
function cloneDeep3(source, hash = new WeakMap()) {

    if (!isObject(source)) return source; 
    if (hash.has(source)) return hash.get(source); // 新增代码，查哈希表
      
    var target = Array.isArray(source) ? [] : {};
    hash.set(source, target); // 新增代码，哈希表设值
    
    for(var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (isObject(source[key])) {
                target[key] = cloneDeep3(source[key], hash); // 新增代码，传入哈希表
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
```

https://juejin.im/post/5c45112e6fb9a04a027aa8fe

