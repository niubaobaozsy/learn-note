# 数据结构相关

## 1，排序算法

https://www.cnblogs.com/onepixel/articles/7674659.html

![1539699183580](image\数据结构.md)

**时间复杂度**：**对排序数据的总的操作次数**。反映当n变化时，操作次数呈现什么规律。

**空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

冒泡：它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，

冒泡最坏是全部逆序

选择：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾

插入：对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。从第一个元素开始往前插入，找到比自己小的位置坐下，从第一个开始，所以前面的都是排好的

希尔排序：计算增量， 1k 2k 3k索引是k的倍数的分为一组，然后进行插入排序（一般第一次分组组里就只有两个元素）。之后k/2，直至k=1

https://www.cnblogs.com/chengxiao/p/6104371.html

归并排序：该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序

就是先把序列分为两半，比如一共15个元素，先把前8排序，这8个在分成4个和4个排，4个又分成2个和2个。最后就2个和2个，第一组的第一个和第二组第一个比进行合并，

快速：从数列中挑出一个元素，称为 “基准”（pivot）；重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

## 2，二叉树的最大深度

给定一个二叉树，找出其最大深度。 
二叉树的深度为根节点到最远叶子节点的距离。

如果二叉树为空，则深度为0 
如果不为空，分别求左子树的深度和右子树的深度，取最大的再加1。

int maxDepth(TreeNode *root) {
​        if(root == nullptr)
​            return 0;

        //分别计算左子树和右子树的深度
        int leftDepth = maxDepth(root->left) + 1;
        int rightDepth = maxDepth(root->right) + 1;
    
        return leftDepth > rightDepth ? leftDepth: rightDepth;
    }
---------------------
