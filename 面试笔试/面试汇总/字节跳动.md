# 字节跳动

笔者读大三，前端小白一枚，正在准备春招，人生第一次面试，投了头条前端，总共经历了四轮技术面试和一轮hr面，不多说，直接上题

## 一面

自我介绍，然后问了为什么学习前端

## 算法：实现36进制转换

把`0.1`转化为二进制是：`0.0001100110011001100...`（1100循环），然后把`0.2`转化为二进制是：`0.00110011001100...`（1100循环）。

十进制小数转为二进制小数采用 乘2取整  ，所以一直是无线循环小数

所以就不精确

parseInt(str,radix); 将字符串str按照radix进制编码方式转换为10进制返回，没有radix，默认为10； 此方法把任意进制字符串转为10进展返回。

eg: console.log(parseInt('23',8));  //19
1
3.
Number的一个方法：toString(radix)；返回表示该数字的指定进制形式的字符串。（把10进制的数据转为指定进制，并以字符串形式输出）；radix支持 [2, 36] 之间的整数。默认为10；

eg：var x = 66;x.toString(16); //“42”

---

## 简述https原理，以及与http的区别

https中信息是加密传输的，但是http是明文

https链接方式不同，https比http在tcp基础上多了一层ssl，https的端口是443 http是80

http无状态，https可加密传输，身份验证

https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

https的原理

就是把https的整个加密流程讲一遍

todo：复习下之前看的https



## 操作系统中进程和线程怎么通信

程有自己的堆栈和局部变量，但线程之间没有单独的地址空间

**进程在执行过程中拥有独立的内存单元**，而**多个线程共享内存**

管道 信号 消息队列 共享内存 信号量 套接口

## node中cluster是怎样开启多进程的，并且一个端口可以被多个进程监听吗

那么nodejs是单线程吗？如果严格的来讲，node存在着多种线程。比如包括：js引擎执行的线程、定时器线程、异步http线程等等这样的。

nodejs是在主线程执行的，其他的异步IO和事件驱动相关的线程是通过libuv来实现内部的线程池和线程调度的。libuv存在着一个Event Loop,通过 Event Loop（事件循环）来切换实现类似多线程的效果。Event Loop 是维持一个执行栈和一个事件队列，在执行栈中，如果有异步IO及定时器等函数的话，就把这些异步回调函数放入到事件队列中。等执行栈执行完成后，会从事件队列中，按照一定的顺序执行事件队列中的异步回调函数。
nodeJS中的单线程是指js引擎只在唯一的主线程上运行的。其他的异步操作是有独立的线程去执行。通过libuv的Event Loop实现了类似多线程的上下文切换以及线程池的调度。线程是最小的进程，因此node也是单进程的。

上第四点，面对单线程单进程对多核使用率不好的问题，因此我们使用多进程，每个进程使用一个cpu，因此我们就可以实现多核cpu的利用。
Node提供了child_process模块和cluster模块来实现多进程以及进程的管理。也就是我们常说的 Master-Worker模式。也就是说进程分为Master(主)进程 和 worker（工作）进程。master进程负责调度或管理worker进程，那么worker进程负责具体的业务处理。在服务器层面来讲，worker可以是一个服务进程，负责出来自于客户端的请求，多个worker就相当于多个服务器，因此就构成了一个服务器群。master进程则负责创建worker，接收客户端的请求，然后分配到各个服务器上去处理，并且监控worker进程的运行状态及进行管理操作。

如上我们了解了使用 child_process实现node集群操作，现在我们来学习使用**cluster模块实现多进程服务充分利用我们的cpu资源以外，还能够帮我们更好地进行进程管理**。我们使用cluster模块来实现我们上面同样的功能

如上代码，我们可以使用 cluster.isMaster 来判断是主进程还是子进程，如果是主进程的话，我**们使用cluster创建了和cpu数量相同的worker进程，并且通过监听 cluster中的online事件来判断worker是否创建成功。并且使用了 cluster监听了 exit事件，当worker进程退出后，会触发master进程中cluster的online事件来判断worker是否创建成功。如下图我们在命令行中运行命令：**



最初的 Node.js 上，多个进程监听同一个端口，它们相互竞争新 accept 过来的连接。这样会导致各个进程的负载很不均衡，于是后来使用了上文提到的 round-robin 策略。具体思路是，master 进程创建 socket，绑定地址并进行监听。该 socket 的 fd 不传递到各个 worker 进程。当 master 进程获取到新的连接时，再决定将 accept 到的客户端连接分发给指定的 worker 处理。简单说就是，master 进程监听端口，然后将连接通过某种分发策略（比如 round-robin），转发给 worker 进程。这样由于只有 master 进程接收客户端连接，就解决了竞争导致的负载不均衡的问题。但是这样设计就要求 master 进程的稳定性足够好了

**大家介绍了 Node.js Cluster 实现多进程的核心原理。重点讲了进程通信、负载均衡以及多进程端口监听三个方面**

简单做个介绍，然后说自己没有深入使用过node

todo：回去看下深入浅出node这本书

https://juejin.im/post/5a6e92815188257349792a65

## 实现原生ajax

```js
/*
 * ajax
 * type === GET: data格式 name=baukh&age=29
 * type === POST: data格式 { name: 'baukh', age:29 }
 * 与 jquery 不同的是,[success, error, complete]返回的第二个参数, 并不是返回错误信息, 而是错误码
 * */
//  var extend = require('./extend');
var utilities = require('./utilities');
function ajax(options) {
    // options = extend(defaults, options);
    var xhr = new XMLHttpRequest();
    var formData = '';
    if (options.data instanceof Object) {
        Object.keys(options.data).forEach(key=>{
          if(formData !== '') {
              formData += '&';
          }
          formData += key + '=' + value;
        })
    }else {
        formData = options.data;
    }
    if(options.type === 'GET' && formData) {
        options.url = options.url + (options.url.indexOf('?') === -1 ?  '?' : '&') + formData;
        formData = null;
    }
    xhr.open(options.type, options.url, options.async);
    for (var key in options.headers) {
        xhr.setRequestHeader(key, options.headers[key]);
    }
    // xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    // 执行发送前事件
    xhr.onreadystatechange = function() {
        if (xhr.readyState !== 4) {
            return;
        }
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
            options.success(xhr.response, xhr.status);
        } else {
            options.error(xhr, xhr.status, xhr.statusText);
        }
    };
    xhr.send(formData);
}
function post(url, data, callback) {
    ajax({ url: url, type: 'POST', data: data, success: callback });
}
function get(url, data, callback) {
    ajax({ url: url, type: 'GET', data: data, success: callback });
}
module.exports = {
    ajax: ajax,
    post: post,
    get: get
};
```

就三步

- `var xhr = new XMLHttpRequest();`
- `xhr.open(options.type, options.url, options.async);`
- `xhr.onreadystatechange`
- `xhr.send(formData);`

## vue-router源码

![img](https://user-gold-cdn.xitu.io/2018/5/8/1633d8c30a032a2d?imageslim)

把这个相关的面试题都侦破 下，这周 h5的api history

todo

## vue原理（手写代码，实现数据劫持）

todo

## 算法：树的遍历有几种方式，实现下层次遍历

```js
var levelOrder = function(root) {
  if(!root) return [];
  let queue=[root];
  let res=[];
  while(queue.length>0){
      let currentLevel=[];
      let len=queue.length;
      while(len){
          let cur=queue.shift();
          currentLevel.push(cur.val);
          if(cur.left) queue.push(cur.left);
          if(cur.right) queue.push(cur.right);
          len--;
      }
      res.push(currentLevel);  
  }
  return res;

};
```

重点是每次循环的时候，保留当前队列的长度，当前队列的长度就是当前层的节点数量

## 算法：判断对称二叉树

```
第一次面试，当时比较紧张，面试官很和蔼，面试中问到操作系统的进程，当时不记得操作系统，
就提到了node多进程，然后面试官就问了cluster是怎样开启多进程的，并且一个端口可以被多个
进程监听吗？答完后面试官就问了后面写完vue数据劫持的时候，面试官又问了Object.defineProperty除了
set get外还有什么属性，我回答了configurable enumerable。vue-router主要提到了hashchange
事件等，顺便跟面试官聊了一下h5的historyAPI。时间总共是50分钟左右，一面完了后面试官让
我等五分钟，接下来二面就开始了
复制代码
```

## 二面

1. 介绍一下项目中的难点

2. let var const 有什么区别

3. 你知道哪些http头部

4. 怎么与服务端保持连接

5. http请求跨域问题，你都知道哪些解决跨域的方法

   

6. webpack怎么优化

7. 你了解哪些请求方法，分别有哪些作用和不同

8. **你觉得typescript和javascript有什么区别**

9. **typescript你都用过哪些类型**

10. **typescript中type和interface的区别**

    interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 **虽然效果差不多，但是两者语法不同**

    - type 可以声明基本类型别名，联合类型，元组等类型
    - type 语句中还可以使用 typeof 获取实例的 类型进行赋值

    - interface 能够声明合并

      

11. react怎么优化

12. 算法题：合并乱序区间

```j
笔者在回答http头部的时候，顺带跟面试官聊到了浏览器缓存，回答跨域的时候，面试官又
让我用jsonp实现一下跨域，回答webpack的时候提到了happypack和treeshaking，面试官就
顺带问了一下他们的作用，算法题我当时没有写出来（主要是因为菜），二面大概40多分钟结
束，面试完后面试官说稍后hr会联系我，让我注意保持通信，还没过一小时，hr打电话约我
第三次面试时间，不得不说，字节的效率真的高
复制代码
```

webpack要回答出如果配置，loader

## 三面

1. 你了解node多进程吗

2. **node进程中怎么通信**

   使用 parentPort 进行父子线程通信

   worker_threads 中使用了 MessagePort（继承于 EventEmitter，[参考](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort)）来实现线程通信。worker 线程实例上有 parentPort 属性，是 MessagePort 类型的一个实例，子线程可利用 postMessage 通过 parentPort 向父线程传递数据

   使用 MessageChannel 实现线程间通信

   worker_threads 还可以支持线程间的直接通信，通过两个连接在一起的 MessagePort 端口，worker_threads 实现了双向通信的 MessageChannel。线程间可通过 postMessage 相互通信

3. 算法题：老师分饼干，每个孩子只能得到一块饼干，但每个孩子想要的饼干大小不尽相同。 目标是尽量让更多的孩子满意。 如孩子的要求是 1, 3, 5, 4, 2，饼干是1, 1， 最多能让1个孩子满足。如孩子的要求是 10, 9, 8, 7, 6，饼干是7, 6, 5，最多能 让2个孩子满足。

4. 算法题：给定一个正整数数列a, 对于其每个区间, 我们都可以计算一个X值; X值的定义如下: 对于任意区间, 其X值等于区间内最小的那个数乘上区间内所有数和; 现在需要你找出数列a的所有区间中, X值最大的那个区间; 如数列a为: 3 1 6 4 5 2; 则X值最大的区间为6, 4, 5, X = 4 * (6+4+5) = 60;

```
三面大概是1小时，面试官比较冷漠，就问你知道不知道，算法思路，然后实现这个算法，
面试完感觉凉凉，但是第二天就收到hr到来的电话，约下一轮的面试时间。
复制代码
```

## 四面

算法题：两个有序链表和并成一个有序链表

https与http有什么区别(一面刚好也被问到)

cookie有哪些属性
cookie,session,localstorage,sessionstorage有什么区别

## 怎么禁止js访问cookie

`response.setHeader("Set-Cookie","deniro=1; Path=/;Domain=www.deniro.net;" +                "Max-Age=30;HTTPOnly");`

1. position有哪些属性
2. 你知道哪些状态码
3. options请求方法有什么用
4. less,sass它们的作用是什么
5. 平时怎么学习
6. 你什么时候可以来实现
7. 能实习多久

```
四面算是比较简单的一次面试，面完后第二天晚上hr打来了电话，约与hr面的时间
复制代码
```

-----

根据自己简历和做过的项目，问一系列相关问题。

闭包的输出值，考查闭包（看试题给结果，分析过程）。

状态码 304 是什么意思，有什么用 ？

浏览器缓存的方法有哪些，它们的优先级是怎样的 ？

都说要减少 https 的请求，https 为什么慢 ？

http2 与 http1 有什么区别 ？

click DOM 节点的 inner 与 outer 的执行机制，考查事件冒泡与事件捕获 （看试题给结果，分析过程）。

for 循环中的 var 、let 与 const 区别，比如 for( const i = 0;  i< 3; i++ ){ console.log(i); } 会输出什么结果 ？（看试题给结果，分析过程）。

有没有系统学习过 es6 或者看过 es6 的书 ？

js 单线程、宏任务与微任务的执行顺序 （看试题给结果，分析过程）。

考查箭头函数的 this 与 普通函数的区别，this 的指向 （看试题给结果，分析过程）。

vue 中 computed 与 watch 的内在是如何实现的 ？

接下来前端要深入的方向 ？

写一个方法输出 ABCDEFG 的值（看试题、现场写程序）。

从排好序的两个链表中，找到相同的节点，并输出链表（看试题、现场写程序）。

-----

作者：夏天梛抹藍
链接：https://www.nowcoder.com/discuss/419857
来源：牛客网



34.TCP 为什么是可靠的？［因为它有 ACK］ 

  35.那 tpc 和 udp 相比的话，udp 有什么好处？虽然不可靠，但是为什么还有很多基于 udp 的协议［因为 upd 报文小，udp 头部8个字节，tcp 头部20个字节，而且有些协议也不需要太可靠。］

----

之后的时间里面，全部就是

1，更深入的计算机网络

2，手写算法题，编程题

3，node

4，项目

