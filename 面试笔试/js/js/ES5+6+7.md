# ES5+6+7

第2章 let和const命令 17
2.1 let 命令 17
2.1.1 基本用法 17
2.1.2 不存在变量提升 19
2.1.3 暂时性死区 19

没申明前不能使用

2.1.4 **不允许重复声明** 21

2.2 块级作用域 22

{}

2.2.1 为什么需要块级作用域 22
2.2.2 ES6的块级作用域 23
2.2.3 块级作用域与函数声明 24
2.2.4 do表达式 27
2.3 const命令 28 （一声明需要立即赋值
2.3.1 基本用法 28
2.3.2 本质 29
2.3.3 ES6声明变量的6种方法 30
2.4 顶层对象的属性 30
2.5 global对象 31
第3章 变量的解构赋值 33 (找到同名的属性，然后再赋值给对应的变量，属性key不会被赋值)
3.1 数组的解构赋值 33
3.1.1 基本用法 33
3.1.2 默认值 35
3.2 对象的解构赋值 37
3.3 字符串的解构赋值 41
3.4 数值和布尔值的解构赋值 41
3.5 函数参数的解构赋值 42
3.6 圆括号问题 43
3.6.1 不能使用圆括号的情况 43
3.6.2 可以使用圆括号的情况 44
3.7 用途 44

for(let [key,index] of map)

for of遍历iterator的接口的对象，map本身就是个数组

第4章 字符串的扩展 49
4.1 字符的Unicode表示法 49
4.2 codePointAt() 50
4.3 String.fromCodePoint() 52
4.4 字符串的遍历器接口 52
4.5 at() 53 （charAt()返回指定index的字符

4.6 normalize() 53
4.7 includes()、startsWith()、endsWith() 54
4.8 repeat() 55
4.9 padStart()、padEnd() 56   es7
4.10 模板字符串 57
4.11 实例：模板编译 60
4.12 标签模板 62
4.13 String.raw() 67
4.14 模板字符串的限制 68
第5章 正则的扩展 71
5.1 RegExp构造函数 71
5.2 字符串的正则方法 72
5.3 u修饰符 72
5.4 y修饰符 74
5.5 sticky属性 77
5.6 flags属性 77
5.7 s修饰符：dotAll模式 78
5.8 后行断言 79
5.9 Unicode属性类 80
5.10 具名组匹配 81
5.10.1 简介 81
5.10.2 解构赋值和替换 82
5.10.3 引用 83
第6章 数值的扩展 85
6.1 二进制和八进制表示法 85
6.2 Number.isFinite()、Number.isNaN() 86
6.3 Number.parseInt()、Number.parseFloat() 87
6.4 Number.isInteger() 88
6.5 Number.EPSILON 88
6.6 安全整数和Number.isSafeInteger() 89
6.7 Math对象的扩展 92
6.7.1 Math.trunc() 92 保留整数部分
6.7.2 Math.sign() 92
6.7.3 Math.cbrt() 93
6.7.4 Math.clz32() 94
6.7.5 Math.imul() 95
6.7.6 Math.fround() 95
6.7.7 Math.hypot() 96
6.7.8 对数方法 96
6.7.9 双曲函数方法 98
6.8 Math.signbit() 98
6.9 指数运算符 99
6.10 Integer数据类型 99
6.10.1 简介 99
6.10.2 运算 100
第7章 函数的扩展 103
7.1 函数参数的默认值 103
7.1.1 基本用法 103
7.1.2 与解构赋值默认值结合使用 105
7.1.3 参数默认值的位置 107
7.1.4 函数的length属性 108  函数的length属性是参数的个数，不包含第一个给了默认值的参数及其后面的参数
7.1.5 作用域 108
7.1.6 应用 111
7.2 rest参数 112
7.3 严格模式 113
7.4 name属性 115
7.5 箭头函数 116  this 不能使用arguments对象，不能用new
7.5.1 基本用法 116
7.5.2 注意事项 118
7.5.3 嵌套的箭头函数 121
7.6 绑定this 123   foo::bar 把foo对象绑定给bar函数作为this

7.7 尾调用优化 124  尾部调用：某个函数的最后一步是调用另外一个函数

functionx{

g(x)

// return undefined

}

上面不是

7.7.1 什么是尾调用 124

这里很难啊，等会复习

7.7.2 尾调用优化 125
7.7.3 尾递归 126
7.7.4 递归函数的改写 128
7.7.5 严格模式 129
7.7.6 尾递归优化的实现 129
7.8 函数参数的尾逗号 132
第8章 数组的扩展 133
8.1 扩展运算符 133
8.1.1 含义 133
8.1.2 替代数组的apply方法 134
8.1.3 扩展运算符的应用 136
8.2 Array.from() 139
8.3 Array.of() 142
8.4 数组实例的copyWithin() 143
8.5 数组实例的find()和findIndex() 144
8.6 数组实例的fill() 145
8.7 数组实例的entries()、keys()和values() 145
8.8 数组实例的includes() 146
8.9 数组的空位 147
第9章 对象的扩展 151
9.1 属性的简洁表示法 151
9.2 属性名表达式 154
9.3 方法的name属性 156
9.4 Object.is() 157
9.5 Object.assign() 158
9.5.1 基本用法 158
9.5.2 注意点 160
9.5.3 常见用途 161
9.6 属性的可枚举性 163
9.7 属性的遍历 165
9.8 __proto__ 属性、Object.setPrototypeOf()、Object.getPrototypeOf() 166
9.8.1 __proto__ 属性 166
9.8.2 Object.setPrototypeOf() 167
9.8.3 Object.getPrototypeOf() 168
9.9 Object.keys()、Object.values()、Object.entries() 169
9.9.1 Object.keys() 169
9.9.2 Object.values() 170
9.9.3 Object.entries 171
9.10 对象的扩展运算符 173
9.11 Object.getOwnPropertyDescriptors() 177
9.12 Null传导运算符 181
第10章 Symbol 183
10.1 概述 183
10.2 作为属性名的Symbol 185
10.3 实例：消除魔术字符串 188
10.4 属性名的遍历 189
10.5 Symbol.for()、Symbol.keyFor() 191
10.6 实例：模块的Singleton模式 192
10.7 内置的Symbol值 194
10.7.1 Symbol.hasInstance 194
10.7.2 Symbol.isConcatSpreadable 195
10.7.3 Symbol.species 196
10.7.4 Symbol.match 197
10.7.5 Symbol.replace 197
10.7.6 Symbol.search 198
10.7.7 Symbol.split 198
10.7.8 Symbol.iterator 199
10.7.9 Symbol.toPrimitive 200
10.7.10 Symbol.toStringTag 201
10.7.11 Symbol.unscopables 202
第11章 Set和Map数据结构 205
11.1 Set 205
11.1.1 基本用法 205
11.1.2 Set实例的属性和方法 207
11.1.3 遍历操作 208
11.2 WeakSet 212
11.2.1 含义 212
11.2.2 语法 212
11.3 Map 214
11.3.1 含义和基本用法 214
11.3.2 实例的属性和操作方法 218
11.3.3 遍历方法 220
11.3.4 与其他数据结构的互相转换 222
11.4 WeakMap 225
11.4.1 含义 225
11.4.2 WeakMap的语法 227
11.4.3 WeakMap示例 228
11.4.4 WeakMap的用途 229
第12章 Proxy 233
12.1 概述 233
12.2 Proxy实例的方法 237
12.2.1 get() 237
12.2.2 set() 241
12.2.3 apply() 243
12.2.4 has() 244
12.2.5 construct() 246
12.2.6 deleteProperty() 247
12.2.7 defineProperty() 248
12.2.8 getOwnPropertyDescriptor() 248
12.2.9 getPrototypeOf() 249
12.2.10 isExtensible() 249
12.2.11 ownKeys() 250
12.2.12 preventExtensions() 254
12.2.13 setPrototypeOf() 255
12.3 Proxy.revocable() 255
12.4 this问题 256
12.5 实例：Web服务的客户端 258
第13章 Reflect 259
13.1 概述 259
13.2 静态方法 261
13.2.1 Reflect.get(target, name, receiver) 262
13.2.2 Reflect.set(target, name, value, receiver) 263
13.2.3 Reflect.has(obj, name) 264
13.2.4 Reflect.deleteProperty(obj, name) 265
13.2.5 Reflect.construct(target, args) 265
13.2.6 Reflect.getPrototypeOf(obj) 265
13.2.7 Reflect.setPrototypeOf(obj, newProto) 266
13.2.8 Reflect.apply(func, thisArg, args) 267
13.2.9 Reflect.defineProperty(target, propertyKey, attributes) 267
13.2.10 Reflect.getOwnPropertyDescriptor (target, propertyKey) 268
13.2.11 Reflect.isExtensible (target) 268
13.2.12 Reflect.preventExtensions(target) 269
13.2.13 Reflect.ownKeys (target) 269
13.3 实例：使用Proxy实现观察者模式 270
第14章 Promise对象 273
14.1 Promise的含义 273
14.2 基本用法 274
14.3 Promise.prototype.then() 278
14.4 Promise.prototype.catch() 279
14.5 Promise.all() 285
14.6 Promise.race() 287
14.7 Promise.resolve() 288
14.8 Promise.reject() 290
14.9 两个有用的附加方法 291
14.9.1 done() 291
14.9.2 finally() 292
14.10 应用 292
14.10.1 加载图片 292
14.10.2 Generator函数与Promise的结合 293
14.11 Promise.try() 294
第15章 Iterator和for...of循环 297
15.1 Iterator（遍历器）的概念 297
15.2 默认Iterator接口 300
15.3 调用Iterator接口的场合 305
15.4 字符串的Iterator接口 307
15.5 Iterator接口与Generator函数 308
15.6 遍历器对象的return()、throw() 309
15.7 for...of循环 310
15.7.1 数组 310
15.7.2 Set和Map结构 311
15.7.3 计算生成的数据结构 312
15.7.4 类似数组的对象 313
15.7.5 对象 314
15.7.6 与其他遍历语法的比较 315
第16章 Generator函数的语法 317
16.1 简介 317
16.1.1 基本概念 317
16.1.2 yield表达式 319
16.1.3 与Iterator接口的关系 322
16.2 next方法的参数 323
16.3 for...of循环 325
16.4 Generator.prototype.throw() 328
16.5 Generator.prototype.return() 334
16.6 yield*表达式 335
16.7 作为对象属性的Generator函数 342
16.8 Generator函数this 342
16.9 含义 345
16.9.1 Generator与状态机 345
16.9.2 Generator与协程 346
16.10 应用 347
16.10.1 异步操作的同步化表达 347
16.10.2 控制流管理 348
16.10.3 部署Iterator接口 351
16.10.4 作为数据结构 352
第17章 Generator函数的异步应用 355
17.1 传统方法 355
17.2 基本概念 355
17.2.1 异步 355
17.2.2 回调函数 356
17.2.3 Promise 356
17.3 Generator函数 357
17.3.1 协程 357
17.3.2 协程的Generator函数实现 358
17.3.3 Generator函数的数据交换和错误处理 359
17.3.4 异步任务的封装 360
17.4 Thunk函数 361
17.4.1 参数的求值策略 361
17.4.2 Thunk函数的含义 362
17.4.3 JavaScript语言的Thunk函数 362
17.4.4 Thunkify模块 364
17.4.5 Generator函数的流程管理 365
17.4.6 Thunk函数的自动流程管理 367
17.5 co模块 368
17.5.1 基本用法 368
17.5.2 co模块的原理 369
17.5.3 基于Promise对象的自动执行 369
17.5.4 co模块的源码 371
17.5.5 处理并发的异步操作 372
17.6 实例：处理 Stream 373
第18章 async函数 375
18.1 含义 375
18.2 用法 377
18.3 语法 379
18.3.1 返回Promise对象 379
18.3.2 Promise对象的状态变化 379
18.3.3 await命令 380
18.3.4 错误处理 382
18.3.5 使用注意点 383
18.4 async函数的实现原理 386
18.5 其他异步处理方法的比较 387
18.6 实例：按顺序完成异步操作 388
18.7 异步遍历器 390
18.7.1 异步遍历的接口 390
18.7.2 for await...of 392
18.7.3 异步Generator函数 393
18.7.4 yield*语句 398
第19章 Class的基本语法 399
19.1 简介 399
19.2 严格模式 403
19.3 constructor方法 403
19.4 类的实例对象 404
19.5 Class表达式 406
19.6 不存在变量提升 407
19.7 私有方法 408
19.8 私有属性 409
19.9 this的指向 410
19.10 name属性 412
19.11 Class的取值函数（getter）和存值函数（setter） 412
19.12 Class的Generator方法 413
19.13 Class的静态方法 414
19.14 Class的静态属性和实例属性 415
19.14.1 Class的实例属性 416
19.14.2 Class的静态属性 417
19.15 new.target属性 418
第20章 Class的继承 421
20.1 简介 421
20.2 Object.getPrototypeOf() 423
20.3 super关键字 423
20.4 类的prototype属性和 __proto__ 属性 429
20.4.1 extends的继承目标 430
20.4.2 实例的 __proto__ 属性 432
20.5 原生构造函数的继承 432
20.6 Mixin模式的实现 436
第21章 修饰器 439
21.1 类的修饰 439
21.2 方法的修饰 442
21.3 为什么修饰器不能用于函数 444
21.4 core-decorators.js 446
21.5 使用修饰器实现自动发布事件 449
21.6 Mixin 450
21.7 Trait 453
21.8 Babel转码器的支持 456
第22章 Module的语法 457
22.1 概述 457
22.2 严格模式 458
22.3 export命令 459
22.4 import命令 462
22.5 模块的整体加载 464
22.6 export default命令 465
22.7 export与import的复合写法 468
22.8 模块的继承 469
22.9 跨模块常量 470
22.10 import() 471
22.10.1 简介 471
22.10.2 适用场合 472
22.10.3 注意点 473
第23章 Module的加载实现 475
23.1 浏览器加载 475
23.1.1 传统方法 475
23.1.2 加载规则 476
23.2 ES6模块与CommonJS模块的差异 477
23.3 Node加载 481
23.3.1 概述 481
23.3.2 import命令加载CommonJS模块 482
23.3.3 require命令加载ES6模块 484
23.4 循环加载 485
23.4.1 CommonJS模块的加载原理 485
23.4.2 CommonJS模块的循环加载 486
23.4.3 ES6模块的循环加载 488
23.5 ES6模块的转码 492
23.5.1 ES6 module transpiler 492
23.5.2 SystemJS 492
第24章 编程风格 495
24.1 块级作用域 495
24.1.1 let取代var 495
24.1.2 全局常量和线程安全 496
24.2 字符串 497
24.3 解构赋值 497
24.4 对象 498
24.5 数组 500
24.6 函数 501
24.7 Map结构 503
24.8 Class 503
24.9 模块 504
24.10 ESLint的使用 506
第25章 读懂ECMAScript规格 509
25.1 概述 509
25.2 相等运算符 510
25.3 数组的空位 511
25.4 数组的map方法 513
第26章 ArrayBuffer 517
26.1 ArrayBuffer对象 518
26.1.1 概述 518
26.1.2 ArrayBuffer.prototype.byteLength 520
26.1.3 ArrayBuffer.prototype.slice() 520
26.1.4 ArrayBuffer.isView() 520
26.2 TypedArray视图 521
26.2.1 概述 521
26.2.2 构造函数 522
26.2.3 数组方法 524
26.2.4 字节序 526
26.2.5 BYTES_PER_ELEMENT属性 528
26.2.6 ArrayBuffer与字符串的互相转换 528
26.2.7 溢出 529
26.2.8 TypedArray.prototype.buffer 531
26.2.9 TypedArray.prototype.byteLength、TypedArray. prototype.byteOffset 531
26.2.10 TypedArray.prototype.length 531
26.2.11 TypedArray.prototype.set() 532
26.2.12 TypedArray.prototype.subarray() 532
26.2.13 TypedArray.prototype.slice() 532
26.2.14 TypedArray.of() 533
26.2.15 TypedArray.from() 533
26.3 复合视图 534
26.4 DataView视图 535
26.5 二进制数组的应用 537
26.5.1 AJAX 537
26.5.2 Canvas 538
26.5.3 WebSocket 539
26.5.4 Fetch API 539
26.5.5 File API 539
26.6 SharedArrayBuffer 541
26.7 Atomics对象 543





