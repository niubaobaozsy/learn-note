# 尚硅谷js高级（2）

### 原型链属性问题

1、读取对象的属性值时：会自动到原型链中查找

2、设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值

fn2.a=yyy

![1534405083069](D:\MyData\zousy1\AppData\Local\Temp\1534405083069.png)

3、方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。

#### 探索instanceof

1、instanceof 是如何判断的？

表达式   A（实例对象） instanceof  B（构造函数）

如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false。

2、Function是通过new自己产生的实例



> 这节包括原型面试题。都没有看。因为之前的没学号。等有好一点基础之后从前面的开始学习到这。



#### 变量提升与函数提升

1、变量声明提升

> **通过var定义**（声明）的变量，在定义语句之前就可以访问到
>
> 值：undefined

2、函数声明提升

> 通过function声明的函数，在之前就可以直接调用
>
> 值：函数定义（对象）

3、问题：变量提升和函数提升是如何产生的

![1534407984727](D:\MyData\zousy1\AppData\Local\Temp\1534407984727.png)

**当一个变量是一个function时，只是这个变量提升了，但是函数没有**

**函数提升必须是声明的方式**

![1534408134870](D:\MyData\zousy1\AppData\Local\Temp\1534408134870.png)

#### 执行上下文

代码分类

1、函数代码

2、全局代码

全局执行上下文

> 1、在执行全局代码前将window确定为全局执行上下文
>
> 2、对全局数据进行预处理
>
> ​	var定义的全局变量=》undefined，添加为window的属性
>
> ​	function声明的全局函数==》赋值（fun），添加为window的方法
>
> ​	this==》赋值（window）
>
> 3、开始执行全局代码

函数执行上下文

> 1、**在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象**
>
> 2、对局部数据进行预处理
>
> ​	形参变量==》赋值（实参）==》添加为执行上下文的属性
>
> ​	arguments==》赋值（实参列表），添加为执行上下文的属性
>
> ​	var定义的局部变量==》undefined，添加为执行上下文的属性
>
> ​	function声明的函数==》赋值（fun），添加为执行上下文的方法。
>
> ​	this==》赋值（调用函数的对象）
>
> 3、开始执行函数体代码

![1534409906962](D:\MyData\zousy1\AppData\Local\Temp\1534409906962.png)

js和java不同的地方、



#### 执行上下文栈

1、在bar函数中，定义的时候调用了foo函数，定义的时候，并没有真正调用。

2、bar（10）这条语句执行时，var foo  = function（y）{}已经执行。所以bar（）调用了bar函数，在bar函数中调用了foo函数。此时foo变量已经指向了函数foo。

调用时才产生执行上下文

![1534411114164](D:\MyData\zousy1\AppData\Local\Temp\1534411114164.png)

每次函数执行完，只有对应函数执行作用域就会出栈消失。

![1534411703018](D:\MyData\zousy1\AppData\Local\Temp\1534411703018.png)

![1534412372018](D:\MyData\zousy1\AppData\Local\Temp\1534468547711.png)

![1534468564762](D:\MyData\zousy1\AppData\Local\Temp\1534468564762.png)

#### 作用域与作用域链

1、理解

​	就是一块“地盘”，一个代码段所在的区域

​	它是静态的（相对于上下文对象），在编写代码时就确定了。

（编写代码时就确定了，函数执行上下文指的是当函数执行时确定的。但是作用域在编写代码就确定了。）

2、分类

​	全局作用域

​	函数作用域

​	没有块作用域（ES6有了）

> js能看到c，就没有块作用域。

> 有多少个作用域：声明了多少个函数再加全局的函数。

3、作用

​	隔离变量，不同作用域下同名变量不会有冲突。

#### 作用域与作用域链

##### 作用域与执行上下文

1、区别1

​	全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数被调用时。

​	全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建

​	函数执行上下文是在调用函数时，函数体代码执行之前创建。

2、区别2

​	作用域是静态的，只要函数定义好了就一直存在，且不会在变化。

​	上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会被释放。

3、联系

​	上下文环境（对象）是从属于所在的作用域

​	全局上下文环境==》全局作用域

​	函数上下文环境==》对应的函数作用域

> 变量——》**当前作用域所在的函数执行上下文找**。找不到，去外部作用域执行上下文环境找。





### 闭包

#### 循环遍历加监听

每个按钮点击后都是弹出“第4个按钮”

> 原因：1、for中定义的i是全局变量。
>
> 2、函数执行，是在for循环完成之后被调用的。被调用时打印i，这时i为4。

### 闭包理解

1、如何产生闭包？
当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包

2、闭包到底是什么

包含被引用变量（函数）的对象

注意：闭包存在于嵌套的内部函数中

3、产生闭包的条件

函数嵌套

内部函数引用了外部函数的数据（变量/函数）

注意：执行函数定义（执行函数声明其实就是创建了一个函数对象，这个对象名就是函数名）就会产生闭包（不用调用内部函数，要调用外部函数，不然内 部函数定义没有被执行）

这里就解释了为什么外部函数只需要执行就会产生内部函数的闭包

外部函数定义，是创建了一个外部函数对象（只有声明，里面的变量a是undefined。内部函数声明并没有执行）。只有当函数执行时，内部函数定义才会执行，才会创建内部函数对象，这个时候闭包就产生了。

注意：外部函数一执行，闭包就产生了。因为函数声明提升，内部函数已经创建。



注意注意：声明提升是什么时候发生的？所以函数的声明提升是声明函数也就是创建了对象。因为函数声明会被提前，而函数声明就是创建函数对象。

是在创建执行上下文时发生的。执行上下文分两种，全局和函数。也就是说，闭包是在外部函数被调用的时候出现的。因为外部函数被调用，需要产生执行上下文。这个时候做声明提升，a为udefined。而内部函数fn2()，创建对应的函数对象。闭包也就产生了。

执行上下文，预处理时给函数声明赋值为对应函数对象（张这样，其实里面有赋值语句var b = 9里面也是一个空的函数对象，没有变量。但是创建了内部函数对象也就有了闭包下图所示）

**每次函数调用都会产生一个新的执行上下文对象，也就会产生一个新的闭包。**



这个时候，22行，闭包没有出现。因为函数定义未执行。

#### 常见的闭包

> fn1()是函数调用，是外部函数调用。当调用外部fn1()时，因为之前声明的时候就已经有了函数fu1（）里面的a是undefined，当调用fn1时，执行a=2再执行return fn2。因为外部函数执行了，a被重新赋值了，内部函数被创建了。闭包也被再次创建了。而f()执行了两次只是执行函数，内部函数没有被创建，所以只有一个闭包。这个闭包里的a一直保存着。所以输出是3 4
>
> 只有当内部函数被创建才会重新创建闭包。



#### 闭包的作用

1、使用函数内部的变量在函数执行完后，依旧存活在内存中（延长了局部变量的生命周期）

2、让函数外部都可以操作（读写）到函数内部的数据（变量/函数）

闭包一直存在的原因，是因为变量f一直引用这对象fn3

改成这样之后闭包不存在了。因为没有引用内部函数对象成为垃圾对象。

> js闭包的作用
>
> 非常类似类的作用
>
> 外部函数相当于一个对象。这个对象包含了对里面变量的操作。
>
> 内部函数相当于这个对象的操作。

变着法的实现类



#### 闭包的生命周期

1、产生：在嵌套内部函数定义执行完成就产生了（不是在调用）

2、死亡：在嵌套的内部函数成为垃圾对象时。



#### 闭包的缺点及解决（内存溢出与内存泄露）

1、缺点

​	函数执行完后，函数内的局部变量没有释放，占用内存时间比较长

​	容易造成内存泄露

2、解决

​	能不用闭包就不用

​	及时释放

##### 内存溢出和内存泄露

1、内存溢出

​	一种程序运行出现的错误

​	当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误

2、内存泄露

​	占用的内存没有及时释放

​	内存泄露积累多了就容易导致内存溢出

​	常见的内存泄露

​		意外的全局变量

​		没有及时清理的计时器或回调函数

​		闭包。

##### JS函数的参数声明中用 var 与不用 var的区别

1、var 声明的变量,作用域是当前 function
2、**没有声明的变量,直接赋值的话, 会自动创建变量，但作用域是全局的.**

输出的是my object。

因为that是 the object。是调用getNameFunc的对象。

输出的是the window

因为 object.getNameFunc()只是返回一个函数。

然后()就是执行这个函数。执行这个函数是window执行。

```
  function Foo() {
    // console.log(getName) 报错，说明没有用var申明的变量，不会变量提升，扩散到全局
      // console.log(getName) 
      getName = 'a';
      return this;
  }
  //  Foo() 函数没有调用之前，不会扩散到全局
  Foo()
  console.log(getName)
```



1.不用var申明的不会变量提升，因为没有声明

```js
  function Foo() {
      getName = function () { alert (1); }; //全局的
      return this;
  }

  Foo.getName = function () { alert (2);};
  Foo.prototype.getName = function () { alert (3);};
  var getName = function () { alert (4);};
  function getName() { alert (5);}
  
  // //请写出以下输出结果：
  Foo.getName(); 
  getName();
  Foo().getName();
  getName();
  new Foo.getName();
  new Foo().getName();
  new new Foo().getName(); // 1,foo里面中的getName是全局的，如果使用var定义的，也被prototype覆盖了

getName() //oaoafly
var getName = function() {
console.log('wscat')
}
getName() //wscat
function getName() {
console.log('oaoafly')
}
getName() //wscat

// 因为存在声明提升，当存在同名的函数和变量，函数优先。但在执行时变量getName的赋值语句开始执行，将函数getname覆盖
// 所以打印出4，而不是5
```

