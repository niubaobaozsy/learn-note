### 谈谈你对作用域链的理解

> 小提示：同类型的问题还可以是原型链、继承、闭包等，这种概念性的问题你肯定不是一句两句能说清楚的，建议在理解之后自己尝试总结一下，如何把重要的知识点用简短的话语说明白。

了解作用域链之前我们要知道一下几个概念：

- 函数的生命周期
- 变量和函数的声明
- Activetion Object（AO）、Variable Object（VO）

函数的生命周期：

- 创建：JS解析引擎进行预解析，会将函数声明提前，同时将该函数放到全局作用域中或当前函数的上一级函数的局部作用域中。
- 执行：JS引擎会将当前函数的局部变量和内部函数进行声明提前，然后再执行业务代码，当函数执行完退出时，释放该函数的执行上下文，并注销该函数的局部变量。

变量和函数的声明：如果变量名和函数名声明时相同，函数优先声明。

Activetion Object（AO）、Variable Object（VO）：

- AO：Activetion Object（活动对象）
- VO：Variable Object（变量对象）

VO对应的是函数创建阶段，JS解析引擎进行预解析时，所有的变量和函数的声明，统称为Variable Object。该变量与执行上下文相关，知道自己的数据存储在哪里，并且知道如何访问。VO是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：

- 变量 (var, 变量声明);
- 函数声明 (FunctionDeclaration, 缩写为FD);
- 函数的形参

AO对应的是函数执行阶段，当函数被调用执行时，会建立一个执行上下文，该执行上下文包含了函数所需的所有变量，该变量共同组成了一个新的对象就是Activetion Object。该对象包含了：

- 函数的所有局部变量（let）
- 函数的所有命名参数
- 函数的参数集合
- 函数的this指向

作用域链：

当代码在一个环境中创建时，会创建变量对象的一个作用域链（scope chain）来保证对执行环境有权访问的变量和函数。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）。如果是函数执行阶段，那么将其activation object（AO）作为作用域链第一个对象，第二个对象是上级函数的执行上下文AO，下一个对象依次类推。

在《JavaScript深入之变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。





# LHS和RHS查询

JavaScript中`编译器阶段`和`js引擎执行过程`都需要作用域的参与，所以我们来详细聊聊`作用域中变量（标识符）的查找规则吧`

### 引擎

从头到尾负责整个JavaScript程序的`编译`及执行过程。

### 编译器

引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

### 作用域

引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

var a=2

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

小结：如果查找的目的是对变量进行赋值，那么就会使用LHS查询；    如果目的是获取变量的值，就会使用RHS查询。

![img](https://user-gold-cdn.xitu.io/2019/3/16/16982853f08e1db5?imageslim)

- 核心重点：变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。
- 函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。

## 2. JavaScript是如何执行的?



![img](https://user-gold-cdn.xitu.io/2019/3/16/16982853f08e1db5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



```
    function foo(a) {
        console.log( a + b );
        b = a;
    }
    foo( 2 );12345
```

报错：ReferenceError: b is not defined （lhs左查询，给左边变量赋值，rhs右边的变量，只是查询这个值）

给变量赋值，这个值不在会报错，如果只是查询这个值，没查到会全局创建

- 核心重点：变量和函数在内的所有声明都会在任何代码被执行前首先 被处理。
- 函数运行的瞬间，创建一个AO (Active Object 活动对象)运行载体。

### 2.1 例子一

```
function a(age) {
    console.log(age);
    var age = 20
    console.log(age);
    function age() {
    }
    console.log(age);
}
a(18);
复制代码
```

#### 2.1.1 分析阶段

函数运行的瞬间，创建一个`AO` (`Active Object 活动对象`)

> AO (Active Object 活动对象) 相当于载体

```
AO = {}
复制代码
```

##### 第一步，分析函数参数：

```
形式参数：AO.age = undefined
实参：AO.age = 18
复制代码
```

##### 第二步，分析变量声明：

```
// 第3行代码有var age
// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事
即AO.age = 18
复制代码
```

##### 第三步，分析函数声明：

```
// 第5行代码有函数age
// 则将function age(){}付给AO.age
AO.age = function age() {}
复制代码
```

##### **函数声明特点：AO上如果有与函数名同名的属性,则会被此函数覆盖。**

> 因为函数在JS领域,也是变量的一种类型

##### 分析阶段最终结果是：

```
AO.age = function age() {}
复制代码
```

#### 2.1.2 执行阶段



![img](https://user-gold-cdn.xitu.io/2019/3/16/16982d8c43b70702?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 2.2 例子二

```
    function a(age) {
        console.log(age);
        var age = function () {
            console.log('25');
        }
    }
    a(18);
复制代码
```

#### 2.2.1 分析阶段

##### 第一步，分析函数参数：

```
形式参数：AO.age = undefined
实参：AO.age = 18
复制代码
```

##### 第二步，分析变量声明：

```
// 第3行代码有函数表达式 var age = function () { console.log('25');}
// 但此前第一步中已有AO.age = 18, 有同名属性,不做任何事
即AO.age = 18
复制代码
```

##### 第三步，分析函数声明（无）

##### 分析阶段最终结果是：

```
AO.age = 18
复制代码
```

#### 2.2.2 执行阶段



![img](https://user-gold-cdn.xitu.io/2019/3/16/16982e2565615b31?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 2.3 例子三

```
 function a(age) {
        console.log(age);
        var age = function () {
            console.log(age);
        }
        age();
    }
a(18);
复制代码
```

#### 2.3.1 分析阶段

##### 第一步，分析函数参数：`AO.age = 18`

##### 第二步，分析变量声明：有同名属性,不做任何事 `AO.age = 18`

##### 第三步，分析函数声明（无）

##### 分析阶段最终结果是：

```
AO.age = 18
复制代码
```

#### 2.3.2 执行阶段



![img](https://user-gold-cdn.xitu.io/2019/3/16/16982f3fe597939b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



到这里，很多人会犯迷糊：`age();`不是应该输出`18` 吗？

代码执行到`age();`时，其实又会再分析 & 执行。

#### 2.3.3 `age()`的分析&执行

```
// 分析阶段
创建AO对象，AO = {}
第一步，分析函数参数（无）
第二步，分析变量声明（无）
第三步，分析函数声明（无）
分析阶段最终结果是：AO = {}
复制代码
```

- 当`age()` 自己的`AO对象`，即`age.AO`是个空对象时，它会往上调用。
- 上一级的`AO对象`是`a`，即`a.AO`, `a.AO`下有个执行完后得到的`a.AO.age = function(){console.log(age);}`
- 输出 `ƒ () { console.log(age); }` `

### 2.4 执行总结：何为作用域链

**JavaScript上每一个函数执行时，会先在自己创建的`AO`上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的`AO`,直到找到大boss:`window`（全局作用域）。 而这一条形成的“`AO`链” 就是`JavaScript`中的作用域链。**

## 4. 作用域链口诀

这里我们拿《你不知道的Javascript(上)》中的一张图解释：



![img](https://user-gold-cdn.xitu.io/2019/3/16/16984b7ccfb56859?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



我也总结了一个**作用域链口诀**，教你快速找到输出：

- 分析阶段创AO，参数看完找变量，变量不顶函数顶，顶完之后定乾坤。
- 执行阶段看LR，内层不行找外层，翻遍楼层找不到，抛个异常连连看。


作者：前端劝退师
链接：https://juejin.im/post/5c8efeb1e51d45614372addd

---

在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：

1. **this** 值的决定，即我们所熟知的 **This 绑定**。
2. 创建**词法环境**组件。
3. 创建**变量环境**组件。

所以执行上下文在概念上表示如下：

```
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
复制代码
```

#### **This 绑定：**

在全局执行上下文中，`this` 的值指向全局对象。(在浏览器中，`this`引用 Window 对象)。

在函数执行上下文中，`this` 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 `this` 会被设置成那个对象，否则 `this` 的值被设置为全局对象或者 `undefined`（在严格模式下）。例如：

```
let foo = {
  baz: function() {
  console.log(this);
  }
}

foo.baz();   // 'this' 引用 'foo', 因为 'baz' 被
             // 对象 'foo' 调用

let bar = foo.baz;

bar();       // 'this' 指向全局 window 对象，因为
             // 没有指定引用对象
复制代码
```

#### 词法环境

[官方的 ES6](http://ecma-international.org/ecma-262/6.0/) 文档把词法环境定义为

> **词法环境**是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义**标识符**和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用**外部**词法环境的空值组成。

简单来说**词法环境**是一种持有**标识符—变量映射**的结构。（这里的**标识符**指的是变量/函数的名字，而**变量**是对实际对象[包含函数类型对象]或原始数据的引用）。

现在，在词法环境的**内部**有两个组件：(1) **环境记录器**和 (2) 一个**外部环境的引用**。

1. **环境记录器**是存储变量和函数声明的实际位置。
2. **外部环境的引用**意味着它可以访问其父级词法环境（作用域）。

**词法环境**有两种类型：

- **全局环境**（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 **null**。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 `this`的值指向全局对象。
- 在**函数环境**中，函数内部用户定义的变量存储在**环境记录器**中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

**环境记录器**也有两种类型（如上！）：

1. **声明式环境记录器**存储变量、函数和参数。
2. **对象环境记录器**用来定义出现在**全局上下文**中的变量和函数的关系。

简而言之，

- 在**全局环境**中，环境记录器是对象环境记录器。
- 在**函数环境**中，环境记录器是声明式环境记录器。

这一块很重要！！

**注意 —** 对于**函数环境**，**声明式环境记录器**还包含了一个传递给函数的 `arguments` 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。

抽象地讲，词法环境在伪代码中看起来像这样：

```
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
    }
    outer: <Global or outer function environment reference>
  }
}
复制代码
```

#### 变量环境：

它同样是一个词法环境，其环境记录器持有**变量声明语句**在执行上下文中创建的绑定关系。

如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。

在 ES6 中，**词法环境**组件和**变量环境**的一个不同就是前者被用来存储函数声明和变量（`let` 和 `const`）绑定，而后者只用来存储 `var` 变量绑定。

我们看点样例代码来理解上面的概念：

```
let a = 20;
const b = 30;
var c;

function multiply(e, f) {
 var g = 20;
 return e * f * g;
}

c = multiply(20, 30);
复制代码
```

执行上下文看起来像这样：

```
GlobalExectionContext = {

  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // 在这里绑定标识符
      c: undefined,
    }
    outer: <null>
  }
}

FunctionExectionContext = {
  ThisBinding: <Global Object>,

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>
  },

VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>
  }
}
复制代码
```

**注意** — 只有遇到调用函数 `multiply` 时，函数执行上下文才会被创建。

可能你已经注意到 `let` 和 `const` 定义的变量并没有关联任何值，但 `var` 定义的变量被设成了 `undefined`。

这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 `undefined`（`var` 情况下），或者未初始化（`let` 和 `const` 情况下）。

这就是为什么你可以在声明之前访问 `var` 定义的变量（虽然是 `undefined`），但是在声明之前访问 `let` 和 `const` 的变量会得到一个引用错误。

这就是我们说的变量声明提升。

### 执行阶段

这是整篇文章中最简单的部分。在此阶段，完成对所有这些变量的分配，最后执行代码。

**注意** — 在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 `let` 变量的值，它会被赋值为 `undefined`。

作者：子非
链接：https://juejin.im/post/5ba32171f265da0ab719a6d7
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

**以上是理解**

-----

## 执行上下文

https://juejin.im/post/5ebced85e51d454dc1467664（讲挺好）

执行上下文里面有个变量对象（ov）

ov在函数被运行时激活为（a0）活动变量。每个函数被调用，都是他的执行上下文压入栈中（函数就是里面的ao压入栈）

### 作用域链（`scope chain`）

**作用域** 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 **作用域链**。

函数的作用域在函数创建时就已经确定了。当函数创建时，会有一个名为 `[[scope]]` 的内部属性保存所有父变量对象到其中。当函数执行时，会创建一个执行环境，然后通过复制函数的 `[[scope]]`  属性中的对象构建起执行环境的作用域链，然后，变量对象 `VO` 被激活生成 `AO` 并添加到作用域链的前端，完整作用域链创建完成：

```
Scope = [AO].concat([[Scope]]);
```

### 当前可执行代码块的调用者（this）

如果当前函数被作为对象方法调用或使用 `bind` `call` `apply` 等 `API` 进行委托调用，则将当前代码块的调用者信息（`this value`）存入当前执行上下文，否则默认为全局对象调用。

关于 `this` 的创建细节，有点烦，有兴趣的话可以进入 [传送门](https://github.com/mqyqingfeng/Blog/issues/7) 学习。

## ES3 执行上下文的生命周期

执行上下文的生命周期有三个阶段，分别是：

- 创建阶段
- 执行阶段
- 销毁阶段

### 创建阶段

函数执行上下文的创建阶段，发生在函数调用时且在执行函数体内的具体代码之前，在创建阶段，JS 引擎会做如下操作：

- 用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。**在这一阶段，会进行变量和函数的初始化声明，变量统一定义为 `undefined` 需要等到赋值时才会有确值，而函数则会直接定义**。

  > 有没有发现这段加粗的描述非常熟悉？没错，这个操作就是  **变量声明提升**（变量和函数声明都会提升，但是函数提升更靠前）。

- 构建作用域链（前面已经说过构建细节）

- 确定 `this` 的值

### 执行阶段

执行阶段中，JS 代码开始逐条执行，在这个阶段，JS  引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出……

### 销毁阶段

一般来讲当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文。

> 注意这只是一般情况，闭包的情况又有所不同。

闭包的定义：**有权访问另一个函数内部变量的函数**。简单说来，如果一个函数被作为另一个函数的返回值，并在外部被引用，那么这个函数就被称为闭包。

```
function funcFactory () {
    var a = 1;
    return function () {
        alert(a);
    }
}

// 闭包
var sayA = funcFactory();
sayA();
复制代码
```

当闭包的父包裹函数执行完成后，父函数本身执行环境的作用域链会被销毁，但是由于闭包的作用域链仍然在引用父函数的变量对象，导致了父函数的变量对象会一直驻存于内存，无法销毁，除非闭包的引用被销毁，闭包不再引用父函数的变量对象，这块内存才能被释放掉。过度使用闭包会造成 **内存泄露** 的问题，这块等到闭包章节再做详细分析。

## ES3 执行上下文总结

对于 `ES3` 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：

1. 函数被调用

2. 在执行具体的函数代码之前，创建了执行上下文

3. 进入执行上下文的创建阶段：

   1. 初始化作用域链

   2. 创建 `arguments object` 检查上下文中的参数，初始化名称和值并创建引用副本

   3. 扫描上下文找到所有函数声明：

      1. 对于每个找到的函数，用它们的原生函数名，在变量对象中创建一个属性，该属性里存放的是一个指向实际内存地址的指针
      2. 如果函数名称已经存在了，属性的引用指针将会被覆盖

   4. 扫描上下文找到所有 

      ```
      var
      ```

       的变量声明：

      1. 对于每个找到的变量声明，用它们的原生变量名，在变量对象中创建一个属性，并且使用 `undefined` 来初始化
      2. 如果变量名作为属性在变量对象中已存在，则不做任何处理并接着扫描

   5. 确定 `this` 值

4. 进入执行上下文的执行阶段：

   1. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。

## ES5 执行上下文总结

对于 `ES5` 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：

1. 程序启动，全局上下文被创建

   1. 创建全局上下文的 

      词法环境

      1. 创建 **对象环境记录器** ，它用来定义出现在 **全局上下文** 中的变量和函数的关系（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为 **`null`**

   2. 创建全局上下文的 

      变量环境

      1. 创建 **对象环境记录器**，它持有 **变量声明语句** 在执行上下文中创建的绑定关系（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为 **`null`**

   3. 确定 `this` 值为全局对象（以浏览器为例，就是 `window` ）

2. 函数被调用，函数上下文被创建

   1. 创建函数上下文的 

      词法环境

      1. 创建  **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `let` 和 `const` 定义的变量）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）

   2. 创建函数上下文的 

      变量环境

      1. 创建  **声明式环境记录器** ，存储变量、函数和参数，它包含了一个传递给函数的 **`arguments`** 对象（此对象存储索引和参数的映射）和传递给函数的参数的 **length**。（负责处理 `var` 定义的变量，初始值为 `undefined` 造成声明提升）
      2. 创建 **外部环境引用**，值为全局对象，或者为父级词法环境（作用域）

   3. 确定 `this` 值

3. 进入函数执行上下文的执行阶段：

   1. 在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。

> 关于 ES5 中执行上下文的变更，个人感觉就是变了个概念，本质和 ES3 差别并不大。至于变更的目的，应该是为了 ES6 中的 let 和 const 服务的。



----

## 执行上下文笔试题

```js
var foo = function () {
    console.log('foo1');
}

foo();

var foo = function () {
    console.log('foo2');
}

foo();
// foo1
//  foo2
// 变量提升，但值是undefined，运行时才确定值
```

```js
foo();

var foo = function foo() {
    console.log('foo1');
}

function foo() {
    console.log('foo2');
}

foo();
// foo2
// foo1
// 变量提升，但值是undefined，运行时才确定值
```

除了第一个，其他全对，over