# JS模块化规范

模块化的好处：1，避免命名冲突（减少命名空间污染）2，更好的分离，按需加载 3，更高复用性 4，高可维护性

模块化带来的问题：请求过多（1个js文件被拆成多个），依赖模糊，难以维护

因此需要规范模块化

## 模块化进化史

1，全局函数模式：将不同的功能封装成不同的全局函数

全局变量，容易被覆盖

2，命名空间模式：简单对象封装

还是能设置对象里面的数据，不安全

3，匿名函数自调用（闭包）

![1541755437807](image/1541755437807.png)

采用依赖注入的方法，将window和jquery注入进入，并把模块化中的数据通过window暴露出去，函数foo中使用的变量则为闭包产生出来的，这个案例中无法修改

## commonjs

#### commonjs基于服务器端（node）应用

![1541756656034](image/1541756656034.png)

commonJS规范是同步加载的，适用于服务器端，但是如果用在浏览器端的话，会造成请求不停等待。而且commonjs中模块语法require()浏览器不识别

暴露的模块到底是什么：其实是module.exports(你将你希望暴露的属性加入这个对象中去)

![1542269037128](image/1542269037128.png)

#### commonjs基于浏览器端的应用

通过使用browserify，在浏览器编译打包commonJs

commonjs的包名不能有大写和中文

![1542269441356](image/1542269441356.png)

![1542269503479](image/1542269503479.png)

局部安装添加了-dev的作用：因为browerify是编译打包工具（打包之后编程dist文件夹下的js文件），所以最后运行环境上不需要加了-dev表示开发依赖，不加是运行依赖，如下图

![1542269711510](image/1542269711510.png)

![1542269961699](image/1542269961699.png)

项目中都封装好了这些步骤

## amd

![1542270247617](image/1542270247617.png)

![1542270267203](image/1542270267203.png)

requireJs

![1542274306180](image/1542274306180.png)

定义没有依赖得模块

![1542274426888](image/1542274426888.png)

定义有依赖得模块

![1542274512799](image/1542274512799.png)

引用上面得模块

![1542275055747](image/1542275055747.png)

1，baseUrl找文件，从baseUrl文件夹下找，如果没有写baseUrl就从当前文件下找

2，path中写模块路径不要加后缀

html页面中得写法

引入require.js文件其中data-main表示js入口

![1542274751309](image/1542274751309.png)

![1542274774997](image/1542274774997.png)

#### amd第三方模块

![1542275441364](image/1542275441364.png)

1，jQuery  模块名需要是小写 jquery

2，angular中模块的名字需要这样写加一个配置

3，路径中开头不能为/

## ES6规范

![1542275637897](image/1542275637897.png)

1，需要编译打包处理

因为很多浏览器还不支持es6中得语法，先用Babel编译为Es5，再解决require（）函数不识别的问题（使用Browserify）

![1542275861507](image/1542275861507.png)

2，安装babel-cli，cli表示命令行接口，就是再命令行中使用babel命令

安装babel中的将es6转化为es5的库babel-preset0es2015

3，定义.babelrc 文件 run control

表示文件为运行时控制文件

暴露模块 

![1542276490065](image/1542276490065.png)

分别暴露

![1542276506663](image/1542276506663.png)

![1542276918472](image/1542276918472.png)

解构赋值的方式接收

>  变量的解构赋值
>
> 1、理解：从对象或数组中提取数据。并赋值1给变量（多个）
>
> 但是明明是按照顺序来接受的，为什么会按照属性名呢？



编译

![1542276604634](image/1542276604634.png)

页面中使用

![1542276629930](image/1542276629930.png)



##### 默认暴露

默认暴露只能有一个，把需要暴露的属性加入默认暴露对象中，接受的时候import中就可以用一个变量接受

![1542277711765](image/1542277711765.png)

![1542277753862](image/1542277753862.png)

使用第三方模块

![1542277949976](image/1542277949976.png)